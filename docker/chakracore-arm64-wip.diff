diff --git a/CMakeLists.txt b/CMakeLists.txt
index cd077075d..357889ded 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -54,6 +54,8 @@ if(CC_USES_SYSTEM_ARCH_SH OR NOT CHAKRACORE_BUILD_SH)
         set(CC_TARGETS_ARM_SH 1)
     elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "arm64")
         set(CC_TARGETS_ARM64_SH 1)
+    elseif(CMAKE_SYSTEM_PROCESSOR STREQUAL "aarch64")
+        set(CC_TARGETS_ARM64_SH 1)
     endif()
     unset(CC_USES_SYSTEM_ARCH_SH CACHE)
 endif()
@@ -68,7 +70,7 @@ elseif(CC_TARGETS_ARM64_SH)
     add_definitions(-D_ARM64_=1)
     add_definitions(-D__arm64__=1)
     set(CC_TARGETS_ARM64 1)
-    set(CMAKE_SYSTEM_PROCESSOr "arm64")
+    set(CMAKE_SYSTEM_PROCESSOR "arm64")
 elseif(CC_TARGETS_X86_SH)
     set(CC_TARGETS_X86 1)
     set(CMAKE_SYSTEM_PROCESSOR "i386")
@@ -293,6 +295,13 @@ elseif(CC_TARGETS_ARM64)
     if(CC_TARGET_OS_OSX)
         add_compile_options(-arch arm64)
     endif()
+    if (CC_TARGET_OS_LINUX)
+      # arm64 .S mostly use ; comments, not accepted by GNU assembler.
+      # In lieu of converting them, just strip the comments during build.
+      set(CMAKE_ASM_COMPILE_OBJECT
+          "sed -e 's/\;.*//g' <SOURCE> > <OBJECT>.masm2gas.S && <CMAKE_ASM_COMPILER> <DEFINES> <INCLUDES> -I $$(dirname <SOURCE>) <FLAGS> -o <OBJECT> -c <OBJECT>.masm2gas.S"
+      )
+    endif()
 else()
     message(FATAL_ERROR "Only AMD64, ARM, ARM64 and I386 are supported")
 endif()
diff --git a/build.sh b/build.sh
index 99ac49fa7..a4a43370a 100755
--- a/build.sh
+++ b/build.sh
@@ -620,7 +620,7 @@ if [[ $ARCH =~ "x86" ]]; then
 elif [[ $ARCH =~ "arm" ]]; then
     ARCH="-DCC_TARGETS_ARM_SH=1"
     echo "Compile Target : arm"
-elif [[ $ARCH =~ "arm64" ]]; then
+elif [[ $ARCH =~ "arm64" || $ARCH =~ "aarch64" ]]; then
     ARCH="-DCC_TARGETS_ARM64_SH=1"
     echo "Compile Target : arm64"
 elif [[ $ARCH =~ "amd64" ]]; then
@@ -634,7 +634,7 @@ fi
 echo Generating $BUILD_TYPE build
 echo $EXTRA_DEFINES
 cmake $CMAKE_GEN -DCHAKRACORE_BUILD_SH=ON $CC_PREFIX $CMAKE_ICU $LTO $LTTNG \
-    $STATIC_LIBRARY $ARCH $TARGET_OS \ $ENABLE_CC_XPLAT_TRACE $EXTRA_DEFINES \
+    $STATIC_LIBRARY $ARCH $TARGET_OS $ENABLE_CC_XPLAT_TRACE $EXTRA_DEFINES \
     -DCMAKE_BUILD_TYPE=$BUILD_TYPE $SANITIZE $NO_JIT $CMAKE_INTL \
     $WITHOUT_FEATURES $WB_FLAG $WB_ARGS $CMAKE_EXPORT_COMPILE_COMMANDS \
     $LIBS_ONLY_BUILD $VALGRIND $BUILD_RELATIVE_DIRECTORY $CCACHE_NAME
diff --git a/lib/Common/Common/arm64/arm64_Get_Current_Frame.S b/lib/Common/Common/arm64/arm64_GET_CURRENT_FRAME.S
similarity index 100%
rename from lib/Common/Common/arm64/arm64_Get_Current_Frame.S
rename to lib/Common/Common/arm64/arm64_GET_CURRENT_FRAME.S
diff --git a/lib/Runtime/Language/SimdInt32x4Operation.cpp b/lib/Runtime/Language/SimdInt32x4Operation.cpp
index e0c01b1a3..fd9ba2f57 100644
--- a/lib/Runtime/Language/SimdInt32x4Operation.cpp
+++ b/lib/Runtime/Language/SimdInt32x4Operation.cpp
@@ -67,7 +67,8 @@ namespace Js
 
         for (uint i = 0; i < 4; i++)
         {
-            if (v.f32[i] >= MIN_INT && v.f32[i] <= MAX_INT)
+            // FIXME: MAX_INT is not exact in float, clang complains about implicit cast
+            if (v.f32[i] >= MIN_INT && v.f32[i] <= (float)MAX_INT)
             {
                 result.u32[i] = (int)(v.f32[i]);
             }
diff --git a/lib/Runtime/Library/JavascriptError.cpp b/lib/Runtime/Library/JavascriptError.cpp
index 3fd9624e3..8570b2d73 100644
--- a/lib/Runtime/Library/JavascriptError.cpp
+++ b/lib/Runtime/Library/JavascriptError.cpp
@@ -396,7 +396,7 @@ namespace Js
 
         if (FACILITY_CONTROL == HRESULT_FACILITY(hr) || FACILITY_JSCRIPT == HRESULT_FACILITY(hr))
         {
-#if !(defined(_M_ARM) && defined(__clang__))
+#if !((defined(_M_ARM) || defined(_M_ARM64)) && defined(__clang__))
             if (argList != nullptr)
 #endif
             {
diff --git a/lib/Runtime/Library/arm64/arm64_CallFunction.S b/lib/Runtime/Library/arm64/arm64_CallFunction.S
index a98154ce7..b73f5315f 100644
--- a/lib/Runtime/Library/arm64/arm64_CallFunction.S
+++ b/lib/Runtime/Library/arm64/arm64_CallFunction.S
@@ -4,13 +4,17 @@
 ; Licensed under the MIT license. See LICENSE.txt file in the project root for full license information.
 ;-------------------------------------------------------------------------------------------------------
 
+#include "unixasmmacros.inc"
+
+// TODO: implement linux vararg calling convention (aapcs) - different from macos (darwinpcs)
+
 ;Var arm64_CallFunction(JavascriptFunction* function, CallInfo info, uint argCount, Var* values, JavascriptMethod entryPoint)
 ;
 ;   This method should be called as follows
 ;       varResult = arm64_CallFunction((JavascriptFunction*)function, args.Info, argCount, args.Values, entryPoint);
 ;
 ;   and makes the following call
-;           return entryPoint(function, info, function, info, values[0], values[1], ..., values[n-2], values[n-1]);
+;           return entryPoint(function, info, values[0], values[1], ..., values[n-2], values[n-1]);
 ;   where n = info.Count
 ;
 ;   ARM64 on macOS puts upto 6 named parameters into x0-x5 and all other parameters (including ...) on the stack
@@ -18,8 +22,6 @@
 ;   Below logic copies them and all other params to stack
 ;
 
-#include "unixasmmacros.inc"
-
 NESTED_ENTRY arm64_CallFunction, _TEXT, NoHandler
 
     PROLOG_SAVE_REG_PAIR_INDEXED fp, lr, -16    ; save FP/LR registers, implicitly stores FP in SP
diff --git a/lib/Runtime/PlatformAgnostic/ChakraPlatform.h b/lib/Runtime/PlatformAgnostic/ChakraPlatform.h
index 35c593f69..555bb2d41 100644
--- a/lib/Runtime/PlatformAgnostic/ChakraPlatform.h
+++ b/lib/Runtime/PlatformAgnostic/ChakraPlatform.h
@@ -20,5 +20,6 @@
 #include "PlatformAgnostic/AssemblyCommon.h"
 
 #if !defined(_WIN32) && defined(DEBUG)
+#undef __reserved   // sal.h define conflicts with linux's signal.h
 #include <signal.h> // raise(SIGINT)
 #endif
diff --git a/lib/Runtime/PlatformAgnostic/Platform/Linux/PerfTrace.cpp b/lib/Runtime/PlatformAgnostic/Platform/Linux/PerfTrace.cpp
index b04ba8368..7e7ff6add 100644
--- a/lib/Runtime/PlatformAgnostic/Platform/Linux/PerfTrace.cpp
+++ b/lib/Runtime/PlatformAgnostic/Platform/Linux/PerfTrace.cpp
@@ -6,6 +6,7 @@
 #include "Runtime.h"
 #include "ChakraPlatform.h"
 
+#undef __reserved   // sal.h define conflicts with linux's signal.h
 #include <signal.h>
 #include <errno.h>
 #include <unistd.h>
diff --git a/pal/inc/pal.h b/pal/inc/pal.h
index 20ca7a80d..1f70b8072 100644
--- a/pal/inc/pal.h
+++ b/pal/inc/pal.h
@@ -2998,7 +2998,11 @@ typedef struct DECLSPEC_ALIGN(16) _CONTEXT {
     // Integer registers
     //
 
+#ifdef __linux__
+    /* +0x004 */ DWORD PState;
+#else
     /* +0x004 */ DWORD Cpsr;       // NZVF + DAIF + CurrentEL + SPSel
+#endif
     /* +0x008 */ union {
                     struct {
                         DWORD64 X0;
diff --git a/pal/src/include/pal/context.h b/pal/src/include/pal/context.h
index 907d13492..e85bbbb33 100644
--- a/pal/src/include/pal/context.h
+++ b/pal/src/include/pal/context.h
@@ -187,7 +187,9 @@ typedef ucontext_t native_context_t;
 #define MCREG_Sp(mc)      ((mc).sp)
 #define MCREG_Pc(mc)      ((mc).pc)
 #define MCREG_PState(mc)  ((mc).pstate)
+#ifndef __linux__
 #define MCREG_Cpsr(mc)    ((mc).cpsr)
+#endif
 #else
     // For FreeBSD, as found in x86/ucontext.h
 #define MCREG_Rbp(mc)	    ((mc).mc_rbp)
diff --git a/pal/src/misc/sysinfo.cpp b/pal/src/misc/sysinfo.cpp
index d33a368a6..6a286daa8 100644
--- a/pal/src/misc/sysinfo.cpp
+++ b/pal/src/misc/sysinfo.cpp
@@ -95,7 +95,9 @@ SET_DEFAULT_DEBUG_CHANNEL(MISC);
 #ifdef __LINUX__
 // There is no reasonable way to get the max. value for the VAS on
 // Linux, so just hardcode the ABI values for 64 and 32bits.
-#ifdef LINUX64
+#if defined(_M_ARM64)
+#define MAX_PROCESS_VA_SPACE_LINUX (1ull << 48)
+#elif defined(LINUX64)
 // The hardware limit for x86-64 CPUs is 256TB, but the practical
 // limit at the moment for Linux kernels is 128TB.  See for example:
 // https://access.redhat.com/articles/rhel-limits
diff --git a/pal/src/thread/context.cpp b/pal/src/thread/context.cpp
index 9fbee9eea..9654e857b 100644
--- a/pal/src/thread/context.cpp
+++ b/pal/src/thread/context.cpp
@@ -122,12 +122,21 @@ typedef int __ptrace_request;
     ASSIGN_REG(R11)     \
     ASSIGN_REG(R12)
 #elif defined(_ARM64_)
+#ifdef __linux__
+#define ASSIGN_CONTROL_REGS \
+    ASSIGN_REG(PState)  \
+    ASSIGN_REG(Fp)      \
+    ASSIGN_REG(Sp)      \
+    ASSIGN_REG(Lr)      \
+    ASSIGN_REG(Pc)
+#else
 #define ASSIGN_CONTROL_REGS \
     ASSIGN_REG(Cpsr)    \
     ASSIGN_REG(Fp)      \
     ASSIGN_REG(Sp)      \
     ASSIGN_REG(Lr)      \
     ASSIGN_REG(Pc)
+#endif
 
 #define ASSIGN_INTEGER_REGS \
     ASSIGN_REG(X0)      \
@@ -545,6 +554,46 @@ CONTEXT_SetThreadContext(
      return ret;
 }
 
+
+#if defined(__linux__) && defined(_ARM64_)
+// Reference: https://github.com/dotnet/runtime/blob/main/src/coreclr/pal/src/thread/context.cpp#L927
+static inline fpsimd_context* _GetNativeSigSimdContext(unsigned char* data, size_t size)
+{
+    size_t pos = 0;
+    while (pos < size)
+    {
+        _aarch64_ctx* ctx = reinterpret_cast<_aarch64_ctx*>(&data[pos]);
+        if (pos + sizeof(_aarch64_ctx) > size)
+        {
+            break;
+        }
+        if (ctx->magic == FPSIMD_MAGIC)
+        {
+            return reinterpret_cast<fpsimd_context*>(ctx);
+        }
+        if (ctx->magic == EXTRA_MAGIC)
+        {
+            extra_context* extra = reinterpret_cast<extra_context*>(ctx);
+            fpsimd_context* fp = _GetNativeSigSimdContext(reinterpret_cast<unsigned char*>(extra->datap), extra->size);
+            if (fp) return fp;
+        }
+        if (ctx->size == 0) {
+            break;
+        }
+        pos += ctx->size;
+    }
+    return nullptr;
+}
+
+static inline fpsimd_context* GetNativeSigSimdContext(native_context_t* native) {
+    return _GetNativeSigSimdContext(static_cast<unsigned char*>(native->uc_mcontext.__reserved), sizeof(native->uc_mcontext.__reserved));
+}
+
+static inline const fpsimd_context* GetConstNativeSigSimdContext(const native_context_t* native) {
+    return GetNativeSigSimdContext(const_cast<native_context_t*>(native));
+}
+#endif
+
 /*++
 Function :
     CONTEXTToNativeContext
